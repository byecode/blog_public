{"meta":{"title":"不已","subtitle":"低调做人，高调做事","description":"不念过去，不惧未来","author":"zyw","url":"https://zyw.io","root":"/"},"pages":[{"title":"文章分类","date":"2020-02-23T09:32:05.000Z","updated":"2021-01-12T13:20:50.456Z","comments":true,"path":"categories/index.html","permalink":"https://zyw.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-02-23T09:31:47.000Z","updated":"2021-01-12T13:20:50.480Z","comments":true,"path":"tags/index.html","permalink":"https://zyw.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"为什么要支持正版？","slug":"why_support_copyright","date":"2020-03-24T09:05:34.000Z","updated":"2021-01-12T13:20:50.456Z","comments":true,"path":"2020/03/24/why_support_copyright/","link":"","permalink":"https://zyw.io/2020/03/24/why_support_copyright/","excerpt":"","text":"1，免费的是最贵的2，盗版软件逼事儿多3，小厂软件别去用","categories":[{"name":"心情","slug":"心情","permalink":"https://zyw.io/categories/%E5%BF%83%E6%83%85/"}],"tags":[{"name":"copyright","slug":"copyright","permalink":"https://zyw.io/tags/copyright/"}]},{"title":"ffdjango新功能get--直播推流","slug":"ffdjango新功能get-直播推流","date":"2020-03-03T15:21:45.000Z","updated":"2021-01-12T13:20:50.456Z","comments":true,"path":"2020/03/03/ffdjango新功能get-直播推流/","link":"","permalink":"https://zyw.io/2020/03/03/ffdjango%E6%96%B0%E5%8A%9F%E8%83%BDget-%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81/","excerpt":"","text":"WIP 批量离线视频 下载完毕之后转换为媒体对象 媒体对象批量转换为直播格式媒体 创建直播单 开启直播 然而好景不长，五分钟就被封了，头条直播还是狠啊","categories":[{"name":"python","slug":"python","permalink":"https://zyw.io/categories/python/"}],"tags":[{"name":"ffdjango","slug":"ffdjango","permalink":"https://zyw.io/tags/ffdjango/"}]},{"title":"自建git服务器","slug":"自建git服务器","date":"2020-03-02T05:07:56.000Z","updated":"2021-01-12T13:20:50.456Z","comments":true,"path":"2020/03/02/自建git服务器/","link":"","permalink":"https://zyw.io/2020/03/02/%E8%87%AA%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"绿茶Git","categories":[],"tags":[]},{"title":"Android中多进程与IPC的恩怨情仇","slug":"android_multiprocess_and_ipc","date":"2020-02-26T10:22:15.000Z","updated":"2021-01-12T13:20:50.456Z","comments":true,"path":"2020/02/26/android_multiprocess_and_ipc/","link":"","permalink":"https://zyw.io/2020/02/26/android_multiprocess_and_ipc/","excerpt":"","text":"题记 可能对大部分人来讲，Android多进程通信貌似没什么用，很少有人使用过 android:process=”” 这个属性，不过对于一些繁重的，甚至可以成为一个单独的App般的业务的module，放在主进程，不仅会互相影响到其稳定性（想想如果这个业务是外部的，那你们需要battle多久？） 跨进程通信的一般姿势 多进程中，我们常见的姿势有哪些呢？ 引子：AIDLAIDL（Android Interface Define Language）作为最基础，做常见的远程通信姿势，常常在各类的 基础、入门、甚至是说那些收费的文章中提及，其使用姿势常常有以下的步骤： 1,定义AIDL文件: 2,通信过程 没错，你一定很好奇，为什么我没有提到那些很多文章中都提到的 Service ？ 不错，虽然Servie是AIDL（或者说是AIDL生成的Binder）最常见的载体，不过，此处我们应该理解的是，真正参与通信过程的是Binder，Parcel，而不是我们所说的 “四大组件” Binder通信的流程，在别的文章中都已经说的很透彻了，此时我们再拿回来，讲讲其中的重要之处： 大部分人见到的binder应该都是这个样子的。正如图上图，binder也确实是这个样子了。可是大部分文章中都少提及了一点，Binder也是可以通过Bundle传输的这就能发挥无限的想象力，比如： 我们常见的操作，ActivityOne –启动–&gt; ActivityTwo, 然后two经过操作，在ActivityOne中接受结果。 ActivityOne 1234567891011121314151617181920212223242526public class ActivityOne extends Activity&#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.test_al).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(ActivityOne.this,ActivityTwo.class); startActivityForResult(intent,0); &#125; &#125;); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if(resultCode == RESULT_OK)&#123; switch (resultCode)&#123; ////do something &#125; &#125; &#125;&#125; ActivityTwo.java 1234567891011public class ActivityTwo extends Activity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); new Handler().postDelayed(() -&gt; &#123; Intent intent = new Intent(); intent.putExtra(\"status\", \"ok\"); setResult(RESULT_OK, intent); &#125;, 2000); &#125;&#125; 这是一般的使用姿势，当然，还会有更简单的方案比如EventBus\\RxBus\\LiveBus等事件总线。也可以干脆写个静态的Listener来接受callback。总之，千奇百怪的姿势都有。 那么，你使用过下面这样的姿势吗？ ActivityOne 1234567891011IView2Result.Stub stub = new IView2Result.Stub() &#123; @Override public void onResult(String data) throws RemoteException &#123; Log.e(\"onResult\", data); &#125;&#125;;Intent intent = new Intent(this,ActivityTwo.class);Bundle bundle = new Bundle();bundle.putBinder(\"binder\",stub.asBinder());intent.putExtra(\"data\",bundle);startActivity(intent); ActivityTwo 1234IBinder binder = getIntent().getExtras().getBinder(\"binder\");IView2Result iView2Result = IView2Result.Stub.asInterface(binder);iView2Result.onResult(\"data\"); IView2Result.aidl 1234interface IView2Result &#123; void onResult(String data);&#125; 没错，这样实现的回调也是可以使用的，相对之前时间总线的来说，这样的操作对跨进程的支持会更优。 后起之秀：MessengerMessenger：作为一个不那么常见的IPC通信方式来说，有着以下的优点 不需要重复的定义Aidl 只需要使用handler来操作，大大的简化了ipc的通信流程 其通信模型如下： 1234567891011121314+---------------+ +---------------+ +---------------+| | | | | || | | | | Process2 || Process1 | | | | + || + +------&gt;+ +-----&gt;+ | || | | | | | | || | | | Messenger | | | || | | | | | | || v | | | | | || +-----+-----+ | | | | v || | Handler | &lt;-------+ +&lt;-----+ +-----+------ +| +-----------+ | | | | | Handler | || | | | | +------------ |+---------------+ +---------------+ +---------------+ 同样的，它也带来了一些显而易见的弊端： 需要定义大量的handlemessage操作 不支持远程通信的callback 当然，这些弊端我们也可以通过一些手段来规避，例如封装一些预置的，通用的操作来对外简化Api，可是对于分离进程常常需要的callback操作，却显得有些力不从心了。 那么有没有一种更优化的方案呢？ 更秀的操作：ContentProviderContentProdiver作为Android中原生的组件支持，常常以一个内容提供者出现。用来封装一些需要跨进程共享的数据来说已经足以支持复杂的场景了。不过，作为一个provider，它也可以对外提供服务。如文章一开始的描述，参与跨进程通信的，是Binder和Parcel，而非组件。而任何可以参与Bundle数据交换的地方，我们都可以使用Binder进行通信。如此一来，出现了很多基于ContentProvider的远程通信方案： 常见的姿势是这样的 12345678910111213141516171819202122+--------------------+ +----------------------+| | | || | | || Process1 | | Process2 || | | |+---+-------^--------+ +------+------^--------+ | | | | | | | | | | | | | | | | | | | | | | | |+------------------------------------------------+| +-----------+ +-----------+ || | AIDL1 +--------------&gt;+ AIDL2 | || | | | | || +-----------+&lt;--------------+-----------+ || || || ContentProvider || |+------------------------------------------------+ Process1 和 Process2 之间使用了ContentProvider进行远程的调用，他们之间通常在Provider进程内还有一个缓存来存放各个进程对应的服务，等需要调用的进程发起调用的时，在Provider查询此服务，然后返回对应的Binder来实现通信。 其面临的弊端也是显而易见的，那就是需要反复的定义各种Aidl服务 以上就是目前阶段我总结的一些基于Binder的远程通信方案。现阶段的远程通信方案，或多或少的都面临着一些问题。这些问题虽然可以通过大量的编码解决，但往往催生一个新技术发展的是消除重复的劳动。所以，在多进程与IPC的恩怨情仇第二篇中，以上的这些问题都将一一解决，同时封装一个强大的，易于维护的远程通信方案！","categories":[{"name":"android","slug":"android","permalink":"https://zyw.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://zyw.io/tags/android/"},{"name":"IPC","slug":"IPC","permalink":"https://zyw.io/tags/IPC/"},{"name":"Binder","slug":"Binder","permalink":"https://zyw.io/tags/Binder/"}]},{"title":"记录下Python部署的坑点（1）","slug":"记录下Python部署的坑点（1）","date":"2020-02-25T14:51:09.000Z","updated":"2021-01-12T13:20:50.456Z","comments":true,"path":"2020/02/25/记录下Python部署的坑点（1）/","link":"","permalink":"https://zyw.io/2020/02/25/%E8%AE%B0%E5%BD%95%E4%B8%8BPython%E9%83%A8%E7%BD%B2%E7%9A%84%E5%9D%91%E7%82%B9%EF%BC%881%EF%BC%89/","excerpt":"","text":"题记 上回说到，django作为我们的后台框架，承载着整体的业务功能。通过其完善 &amp; 强大的后台支持，我们可以在很短的时间内得到想要的一系列，不过作为一个新手，遇到坑也是难免的，本文记录萌新遇到的常见问题 坑点一 数据库指令问题 第一个坑点：通过管理工具创建的数据库指令，对于PK键不会生效，也就是我们插入的自增主键是不会有这个属性的，需要到mysql后台修改。 坑点二 Debug开关问题 部署到正式环境一定要关闭DEBUG，一定要关闭，虽然官方好心的提示了会造成内存泄露问题,可是新手尝尝会遇到这个问题而莫名其妙的被kill掉celery的worker。 昨天跑了一个离线任务发现celery在django环境下，跑时间较长的任务会出现内存不足被系统kill掉的问题，这个点一定要记牢。 坑点三 静态文件支持:debug环境的话，django会自动的帮我们部署静态文件，想怎么玩就怎么玩，可是到了正式环境，我们需要在HttpService上配置好静态的规则，同时在Setting.py中指定静态目录： Setting.py 1234567891011STATIC_URL = '/static/'MEDIA_IMAGE_DIR_PREFIX = \"img\"STATICFILES_DIRS = ( os.path.join('static'), )MEDIA_OUTPUT = os.path.join('static',\"output\")LX_OUTPUT = os.path.join('static',\"lx\")ALLOW_EXT = [\".mp4\",\".flv\",\".avi\"] Nginx Config 1234location /static/ &#123; alias /home/www/wwwroot/ffdjango/static/; &#125; PS：记得执行 collectstatic 来收集下静态文件！！ 坑点四 Celery 问题：使用 supervisord 部署Celery服务的时候，一定记得先kill掉之前的进程，否则你会看到一片密密麻麻的CeleryWorker 放上我的启动脚本： celery.sh 1234#!/bin/bashsudo pkill -9 -f 'celery'source $1/bin/activatecelery -A ffdjango worker -l info --concurrency=2 以上就是趟过的坑，先记录下，供后期查阅","categories":[{"name":"python","slug":"python","permalink":"https://zyw.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zyw.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://zyw.io/tags/django/"},{"name":"celery","slug":"celery","permalink":"https://zyw.io/tags/celery/"}]},{"title":"从2开始打造的云转码-一张”假“图片","slug":"从2开始打造的云转码-一张”假“图片","date":"2020-02-23T15:36:31.000Z","updated":"2021-01-12T13:20:50.456Z","comments":true,"path":"2020/02/23/从2开始打造的云转码-一张”假“图片/","link":"","permalink":"https://zyw.io/2020/02/23/%E4%BB%8E2%E5%BC%80%E5%A7%8B%E6%89%93%E9%80%A0%E7%9A%84%E4%BA%91%E8%BD%AC%E7%A0%81-%E4%B8%80%E5%BC%A0%E2%80%9D%E5%81%87%E2%80%9C%E5%9B%BE%E7%89%87/","excerpt":"","text":"题记书接上回，我们提到了自动下载ffmpeg并且自动配置到环境变量中，ffmpeg的问题得到了完美的解决。此时又有一个问题来了，视频云意味着【烧钱】，流量，cdn，存储，都是大头。那么如何做到几乎0成本的存储视频呢？ 图床的妙用现在的互联网上，各式各样的图床应有尽有。大部分都是已经运行了很久的图床，比如 路过图床，sm.ms等，如果切片之后的ts文件能存在这里，那么该多幸福啊.. 幻想终究是幻想，如果我们尝试着将一个.ts文件上传到上述的图床上的时候，他会提示我们 路被堵死了吗？其实并不然，经过尝试，把ts文件合并到图片中，不会影响原有的图片，并且！我们可以把这批图床利用起来了 比如这张图片： video-000000.jpg 100%[===========================&gt;] 8.20M 190KB/s in 39s 一张jpg图片大小8.2M，成功的将ts文件混入其中，那我们尝试传到图床上呢？ 这里我插入了一个经过修改的hls.js的库，可以支持特殊的图片切面ts文件，接下来是测试。打开控制台可以清楚的看到这些都是伪装好的图片。而其中的ts部分是可以经过修改版的js解析的。 后台中添加： (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer1\"),\"autoplay\":true,\"video\":{\"url\":\"https://api.mov.pw/media/cdn_media/10/8c7b0d745ac24cf096484ea6cc5f6491/index.m3u8\",\"type\":\"hls\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()","categories":[{"name":"python","slug":"python","permalink":"https://zyw.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zyw.io/tags/python/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://zyw.io/tags/ffmpeg/"},{"name":"图床","slug":"图床","permalink":"https://zyw.io/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"从1开始打造的云转码-Ffmpeg的问题","slug":"从1开始打造的云转码-Ffmpeg的问题","date":"2020-02-23T15:23:40.000Z","updated":"2021-01-12T13:20:50.456Z","comments":true,"path":"2020/02/23/从1开始打造的云转码-Ffmpeg的问题/","link":"","permalink":"https://zyw.io/2020/02/23/%E4%BB%8E1%E5%BC%80%E5%A7%8B%E6%89%93%E9%80%A0%E7%9A%84%E4%BA%91%E8%BD%AC%E7%A0%81-Ffmpeg%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"题记 由上一篇中的一个需求（ffmpeg安装的问题），简单思考了下如何在不安装的情况下使用ffmpeg呢？ ffmpeg从哪来？ffmpeg不多介绍，强大的功能是他能使用的如此广泛的原因之一。不过因为全部市面上可见的操作系统都不会内置，需要额外的安装操作，这对于懒一些的用户来说是不可接受的，那么怎么办？ 1 脚本中增加【自动】安装的流程? 对于一个觉得shell是反人类的developer来说，这是不可接受的 2 下载预编译的ffmpeg 无论对developer还是对user来说，没有【编译流程】或者叫做【急速安装】的功能都是比较优化的（虽然有人说在自己的平台上定制会”性能更好“）。既然我们已经用全栈的python了，何不启动的时候通过python自动的配置好ffmpeg的环境呢？ 方案落地预编译的ffmpeg来源有如下几个 12345windows: https://ffmpeg.zeranoe.com/builds/win64/static/linux:https://johnvansickle.com/ffmpeg/releases/osx:https://evermeet.cx/ffmpeg/ GitlabCI + Gitlab Page 的妙用gitlab是一家良心的git服务提供商（包括我的博客也落在上面），其提供了一套强大的CI服务，可以在提交的时候自动编译、发布一些产物。官方也提供了一个静态发布的博客 demo借助其页面发布功能，我们可以自动更新ffmpeg的最新版本，发布到gitlab page上 这是我利用gitlabCI制作的全套ffmpeg二进制文件 FFmpeg 这是发布所需的ci规则，其中 download.sh 用于下载二进制文件并解压，makeindex.sh 用于制作一个简单（漏）的首页。 1234567891011121314151617181920212223242526before_script: - apt-get update -y - apt-get install curl -y - apt-get install p7zip-full -y - chmod a+x download.sh - chmod a+x makeindex.sh - PATH=$PATH:. - mkdir public - mkdir public/win32-x64 - mkdir public/win32-ia32 - mkdir public/linux-x64 - mkdir public/linux-ia32 - mkdir public/linux-arm - mkdir public/linux-arm64 - mkdir public/darwin-x64 pages: stage: deploy script: - sh download.sh - sh makeindex.sh public artifacts: paths: - public only: - master python自动下载的流程利用request下载，然后配置到环境中就可以了，大概的流程如下： 12345def download_ffmpeg() download_url = \"http://ffmpeg.down.asia/&#123;os_platform&#125;-&#123;arch&#125;/&#123;file&#125;\".format(os_platform=os_platform, arch=arch, file=target_file) r = requests.get(download_url, stream=True) ... download… 123456789def setup(): ffprob_path = get_ffprobe_path() target_ff_path = os.path.join(os.path.dirname(sys.executable), \"ffmpeg\") target_fp_path = os.path.join(os.path.dirname(sys.executable), \"ffprobe\") if not os.path.exists(target_ff_path): os.symlink(ffmpeg_path, target_ff_path) if not os.path.exists(target_fp_path): os.symlink(ffprob_path, target_fp_path) 这样一来，我们只要在合适的时机执行下这个脚本就可以了~","categories":[{"name":"python","slug":"python","permalink":"https://zyw.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zyw.io/tags/python/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://zyw.io/tags/ffmpeg/"}]},{"title":"从0开始打造的云转码-开篇","slug":"从0开始打造的云转码-开篇","date":"2020-02-23T07:14:35.000Z","updated":"2021-01-12T13:20:50.456Z","comments":true,"path":"2020/02/23/从0开始打造的云转码-开篇/","link":"","permalink":"https://zyw.io/2020/02/23/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%89%93%E9%80%A0%E7%9A%84%E4%BA%91%E8%BD%AC%E7%A0%81-%E5%BC%80%E7%AF%87/","excerpt":"","text":"题记 不知不觉中，马上就要步入30岁的大关了，新年立下的Flag之一就是坚持写博客，那么就开始吧… 我们想要什么样的功能？ 思考一个产品其目标，当然最终的目的就是给用户（当然可以使自己），用着舒服，用的省心，功能强大，操作简单，以我自己作为一个最终的用户考量的话，那么… 基本的编解码功能要有，切片要有，截封面图（支持gif）要有，强大的同步功能 要能离线下载，这样我部署完了之后就可以挂机等着了 要能推流，我想做个电台直播间 一定要部署起来简单，最好跟当初的php without composer 的一样一样的. 可靠性强大 扩展性强，最好能自己写插件 任务管理不要太费劲 . . . . 基于以上几点，选择技术栈 转码，切片，多媒体操作 -&gt; Ffmpeg 快速搞后台 Django Ffmpeg 不需要手动安装 Celery作为强有力的异步任务支撑，已经收到了广大的商品化的验证 离线下载的话，you-get 搞定一切 当我写完这篇文章的时候，其实功能已经差不多了 😁 基本的雏形完成 插入一个视频试试 (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"autoplay\":true,\"theme\":\"#FADFA3\",\"video\":{\"url\":\"https://api.mov.pw/media/hls_media/9/index.m3u8\",\"type\":\"hls\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()","categories":[{"name":"python","slug":"python","permalink":"https://zyw.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zyw.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://zyw.io/tags/django/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://zyw.io/tags/ffmpeg/"},{"name":"转码","slug":"转码","permalink":"https://zyw.io/tags/%E8%BD%AC%E7%A0%81/"}]},{"title":"A simple way to block Android 's fast click event","slug":"A simple Way to Avoid Fast-Double-Click","date":"2020-02-23T06:38:04.000Z","updated":"2021-01-12T13:20:50.452Z","comments":true,"path":"2020/02/23/A simple Way to Avoid Fast-Double-Click/","link":"","permalink":"https://zyw.io/2020/02/23/A%20simple%20Way%20to%20Avoid%20Fast-Double-Click/","excerpt":"","text":"Fast-Click is Always a trouble in Android development.such as a button clicklistener implements in order jumping to another Activity.It will seem like follow: 12345678910111213public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btn_test).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; startActivity(new Intent(MainActivity.this,MainActivity.class)); &#125; &#125;); &#125;&#125; But if you clicking fast in a tiny duration , It will open two target Activity. A simple way to avoid this issue is set the target launchMode to single top or single instance. like this : 12345678&lt;activity android:name=\"debug.MainActivity\" android:launchMode=\"singleInstance\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; But , if there is a great count of Activity in your Manifest ,it will be a ‘treasure’:smile other simple way is add pre time check on click listener. like this: 1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btn_test).setOnClickListener(new View.OnClickListener() &#123; private long lastClickTime = 0; @Override public void onClick(View view) &#123; if(System.currentTimeMillis() - lastClickTime &gt; 1000)&#123; startActivity(new Intent(MainActivity.this,MainActivity.class)); &#125; lastClickTime = SystemClock.currentThreadTimeMillis(); &#125; &#125;); &#125;&#125; If your has a lot of OnClickListener it will be your disaster.Here is a solution to resove the fast-double-click problems. The SolutionAll we know ,the View use TouchEvent to perform onClick Event, if the event can be hook or intercept in all view, the trouble can be done. I found a hook-point seem to be very fitted to do this.In View’s class members , here is a Field named mAttachInfo. provided View’s post() method implements. If you interest in read the fucking source , you can simply know the view’s touch event will post a Runnable to Perform ClickEvent. the Runnable named android.view.View.PerformClick here is the implement code : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package com.yixia.utils;import android.app.Activity;import android.os.Handler;import android.os.Message;import android.util.Log;import android.view.View;import java.lang.reflect.Field;import java.util.HashMap;/** * @author yixia zhangyanwei@yixia.com * @version version_code * @Copyright (c) 2017 miaopai * @Description * @date 2017/10/11 */public class DBClickBlocker extends Handler &#123; private static final String TAG = \"DBClickBlocker\"; private static final long DOUBLE_CLICK_TIME = 2000; private HashMap&lt;Runnable, Long&gt; mClickTimes = new HashMap&lt;&gt;(); private Handler mOrigHandler = null; static &#123; try &#123; ATTACH_INFO_FIELD = View.class.getDeclaredField(\"mAttachInfo\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private static Field ATTACH_INFO_FIELD; public static void apply(Activity activity) &#123; try &#123; View decorView = activity.getWindow().getDecorView(); if (ATTACH_INFO_FIELD == null) &#123; Log.e(TAG, \"un support device\"); return; &#125; ATTACH_INFO_FIELD.setAccessible(true); Object attachInfo = ATTACH_INFO_FIELD.get(decorView); if (attachInfo == null &amp;&amp; decorView != null) &#123; decorView.addOnAttachStateChangeListener(new View.OnAttachStateChangeListener() &#123; @Override public void onViewAttachedToWindow(View v) &#123; try &#123; Object _attachInfo = ATTACH_INFO_FIELD.get(v); applyInner(_attachInfo); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onViewDetachedFromWindow(View v) &#123; Log.e(TAG, \"remove callback success\"); v.removeOnAttachStateChangeListener(this); &#125; &#125;); &#125; else if (attachInfo != null &amp;&amp; decorView != null) &#123; applyInner(attachInfo); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void apply(View view) &#123; try &#123; if (ATTACH_INFO_FIELD == null) &#123; Log.e(TAG, \"un support device\"); return; &#125; ATTACH_INFO_FIELD.setAccessible(true); Object attachInfo = ATTACH_INFO_FIELD.get(view); if (attachInfo == null &amp;&amp; view != null) &#123; view.addOnAttachStateChangeListener(new View.OnAttachStateChangeListener() &#123; @Override public void onViewAttachedToWindow(View v) &#123; try &#123; Object _attachInfo = ATTACH_INFO_FIELD.get(v); applyInner(_attachInfo); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onViewDetachedFromWindow(View v) &#123; Log.e(TAG, \"remove callback success\"); v.removeOnAttachStateChangeListener(this); &#125; &#125;); &#125; else if (attachInfo != null &amp;&amp; view != null) &#123; applyInner(attachInfo); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private static void applyInner(Object attachInfo) throws Exception &#123; if (attachInfo != null) &#123; Field mHandler = attachInfo.getClass().getDeclaredField(\"mHandler\"); mHandler.setAccessible(true); Handler mAttachInfoHandler = (Handler) mHandler.get(attachInfo); mHandler.set(attachInfo, new DBClickBlocker(mAttachInfoHandler)); Log.e(TAG, \"install double blocker success !\"); &#125; &#125; public DBClickBlocker(Handler mOrigHandler) &#123; this.mOrigHandler = mOrigHandler; &#125; @Override public void dispatchMessage(Message msg) &#123; mOrigHandler.dispatchMessage(msg); &#125; @Override public String getMessageName(Message message) &#123; return mOrigHandler.getMessageName(message); &#125; @Override public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; if (msg.getCallback() != null &amp;&amp; \"android.view.View.PerformClick\".equals( msg.getCallback().getClass().getCanonicalName())) &#123; long currentTime = System.currentTimeMillis(); if (mClickTimes.containsKey(msg.getCallback())) &#123; if (currentTime - mClickTimes.get(msg.getCallback()) &gt; DOUBLE_CLICK_TIME) &#123; //超过双击时间，可以双击 Log.e(TAG,\"block over time...\"); mClickTimes.put(msg.getCallback(), currentTime); return mOrigHandler.sendMessageAtTime(msg, uptimeMillis); &#125; else &#123; Log.e(TAG,\"block over success...\"); return true; &#125; &#125; else &#123; Log.e(TAG,\"block over new...\"); mClickTimes.put(msg.getCallback(), currentTime); return mOrigHandler.sendMessageAtTime(msg, uptimeMillis); &#125; &#125; return mOrigHandler.sendMessageAtTime(msg, uptimeMillis); &#125; @Override public String toString() &#123; return mOrigHandler.toString(); &#125; @Override public void handleMessage(Message msg) &#123; mOrigHandler.handleMessage(msg); &#125;&#125; Update: simple way to import dependencies dependencies { compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile &apos;com.android.support:appcompat-v7:24.2.0&apos; compile &apos;io.zyw.os:fastclickblocker:1.1&apos; } Usage: DBClickBlocker.apply(Activty or View); all is done.~ Sample","categories":[{"name":"android","slug":"android","permalink":"https://zyw.io/categories/android/"}],"tags":[]},{"title":"下一代秒拍组件化构思","slug":"下一代秒拍组件化构思","date":"2018-10-31T08:47:56.000Z","updated":"2021-01-12T13:20:50.456Z","comments":true,"path":"2018/10/31/下一代秒拍组件化构思/","link":"","permalink":"https://zyw.io/2018/10/31/%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%A7%92%E6%8B%8D%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9E%84%E6%80%9D/","excerpt":"","text":"目前阶段的秒拍工程已经有了一套成熟的组件化体系，不过仍然很多问题等待解决。 1.组件化完全依赖于工程的一些配置文件，导致没有一定经验的开发人员不能合理的把控好开闭原则。 2.当时提出的构想（组建一键切换为插件）仍然没有实现 3.繁琐的配置会容易出错。为了解决这些问题，所以将提出下一代组件化的框架。 1.基本思路 主工程到底应该依赖什么？ 现阶段的主工程，都是通过gradle的dependence直接compile引入gradle工程内部的project，如果可以更换一种方式，比如通过 “compile远程依赖”,来引入其他工程，内部的module也都加上版本控制，这样会大大增加工程的稳定性。 主工程配置如下 1234MpAppWrapperConfig &#123; localMavenDir = \"mpLocalMaven\" exclude['yxplayer']&#125; 其中，localMavenDir ，为指定的一个本地maven目录。通过此方法，构建一个本地的maven。然后其他工程publish到此maven目录下，可以增加编译的速度。 module怎样定义最好？ 现在控制是否为单独编译模式存在着很大的隐患，配置文件都是通过明显的配置项在gradle.properties中配置。完全可以通过gradle plugin的方式来控制这些东西 module 中的config如下 12345678MpCompConfig &#123; moduleName &#x3D; &quot;com.yixia.module.player&quot; debugDir &#x3D; [&#39;src&#x2F;debug&#x2F;java&#39;] debugResDir &#x3D; [&#39;src&#x2F;debug&#x2F;res&#39;] launcherActivity &#x3D; &quot;com.yixia.module.player.DebugActivity&quot; app &#x3D; &quot;com.yixia.module.player.PYApplication&quot; localMavenDir &#x3D; &quot;mpLocalMaven&quot;&#125; 这里的配置项比较多，依次列举。 moduleName指定独立编译期间的包名。 debugDir，独立APP模式下的目录，在Module会剔除这项。 debugResDir，独立模式下的res目录。 launcherActivity ，独立模式下的主Debug用Activity。 app ,此工程的独立app，如编译进主工程会自动打包进入application。 localMavenDir输出的maven地址。","categories":[{"name":"android","slug":"android","permalink":"https://zyw.io/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://zyw.io/tags/android/"},{"name":"AOP","slug":"AOP","permalink":"https://zyw.io/tags/AOP/"},{"name":"组件化","slug":"组件化","permalink":"https://zyw.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"tramsform","slug":"tramsform","permalink":"https://zyw.io/tags/tramsform/"},{"name":"gradle","slug":"gradle","permalink":"https://zyw.io/tags/gradle/"}]},{"title":"秒拍的组件化演进","slug":"秒拍的组件化演进","date":"2018-09-12T08:23:24.000Z","updated":"2021-01-12T13:20:50.456Z","comments":true,"path":"2018/09/12/秒拍的组件化演进/","link":"","permalink":"https://zyw.io/2018/09/12/%E7%A7%92%E6%8B%8D%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96%E6%BC%94%E8%BF%9B/","excerpt":"","text":"组件化的反思：最早的组件化概念应该是从OSGI模型演变过来的。当时在JavaWeb领域，开发者为了将服务细分，出现了面向接口编程的思路。而由于工程的庞大再加上单纯的规范已经不能严格要求开发人员按照约定的规范进行 “接口” 编程了。组件化由此应运而生。 组件化的出现就是为了解决几个问题： 功能拆分 解耦 组建单独编译，不影响整个工程。 Android 平台的早期组件化思路 底层Framework为基础业务，所有公共的功能在此体现。 上层组建单独依赖于FrameWork 项目结构: 1234567891011 +------------------------------+ | | +--------+ FrameWork +---+ | | | | | +-----------+------------------+ | | | |+--------v-------+ +-------v--------+ +--------v--------+| | | | | || User Comp | | Chat Comp | | Other Comp || | | | | |+----------------+ +----------------+ +-----------------+ 此时，已经基本实现了简单的模块化操作，可是这样的工程结构有如下问题： 项目间功能调用无法实现：如 Chat模块跟 User模块间的相互调用，IM登陆用到的用户字段，用户字段中要包含IM中的状态等等。 资源文件重复使用问题 一系列其他问题 当然以上问题也是有解决方案的，可以通过不断的将 所谓的 公有功能迁移到Framework中解决，不过，将会出现如下问题。 FrameWork 越来越臃肿的问题。 这并不是我们希望看到的。 早在2017年我就提出过组建即插件的理论。我们也在向着这个目标发展，不过如果继续使用上述的组建模型，将是灾难性的后果。 有幸后来得到了得到了一次新项目开发的机会。我们就此在新项目上继续推进我们的组建框架。 新的组件化推进：关于组件化的思路，我们开始分析上述模型中的失误部分，最大的问题还是耦合性没有解开，如何“强制” 的让组建之间领依赖成为一个严峻的问题。 同时为了单独编译组建的时候不将无用代码编译进去。我们进行了新的组件化拆分。 新的组件化框架思路： 1234567891011121314151617181920212223242526+-------------------------------------------------------------------+| || +------------+ +------------+ +----------+ +-----------+ || | Common | | Birdge | | UiLibs | | Other | || | | | | | | | | || +------------+ +------------+ +----------+ +-----------+ || || BaseModule |+---------------+----------------------------+----------------------+ | | | | | | +------------v----------------------------v-------------------+ | | | +----------+ +----------+ +----------+ +--------+ | | | User | | Home | | Feed | | Search | | | +----------+ +----------+ +----------+ +--------+ | | | | Function Module | +-------------------------------------------------------------+ +----------------------------+ | | | App Wrapper | | | +----------------------------+ Base Module 编译类型为Android的library。 Common提供工程的基础支撑，原有的 common中大部分重叠的功能都放在了这里。 Bridge 中为工程的 【接口规范】和所有的Bean。 UiLibs 为工程中要到的基础UI控件和资源。 Other 中包含其他基础组件支持，如 push ,plugin ，player等 Function Module 编译类型随开关改变工程的业务组件，包含一个可调试的 TestActivity 和一个 可调试的 DebugApplication。会在编译为工程的时候自动剔除掉。 其他为一些单独的业务功能。 和其他常见的组件化框架相比也没有特别之处。都是通过sourceSets 来控制的。 12345678910111213sourceSets &#123; main &#123; if (isModule.toBoolean()) &#123; manifest.srcFile 'src/main/module/AndroidManifest.xml' &#125; else &#123; manifest.srcFile 'src/main/AndroidManifest.xml' java &#123; exclude 'debug/**' &#125; &#125; jniLibs.srcDirs = ['libs'] &#125;&#125; 其中 isModule 是工程中定义的组件化开关,定义在工程根目录的 gradle.properties文件中。 两个魔法般的注解@AutoInit 和 @BindLife@AutoInit 是一个 远程 依赖引入的注解。它可将别的Module下的具体实现 引入到当前这个不可见的范围内。比如 User 工程中 有一个 UserManager控制用户的登录退出操作 ，而Chat 工程中，要检测登陆，这两个工程是 不能相互依赖的。我们的方案： Bridge 中 定义 IUserManager12345678910public interface IUserManager &#123; boolean isLogin(); UserBean getCurrentUser(); void logout(); void login(UserBean userBean);&#125; Chat工程中引用12345678910111213141516public class ChatManager &#123; //注意这里，在模块开发阶段，这里可定义成 debug包下的空实现类 @AutoInit(implclass= \"com.yixia.chat.debug.DebugUserManager\") IUserManager mUserManager; public boolean conn(ChatUserBean _chatuser,boolean shouldReConn)&#123; //... if(!mUserManager.isLogin)&#123; return false; &#125; //... &#125;&#125; 同时，Chat 工程中可在debug包中定义一个空的实现类123456789101112131415161718public class DebugUserManager implements IUserManager&#123; private UserBean mUser = null; public boolean isLogin()&#123; return mUser != null; &#125; public UserBean getCurrentUser()&#123; return mUser; &#125; public void logout()&#123; mUser = null; &#125; public void login(UserBean userBean)&#123; mUser = userBean; &#125;&#125; 等到联合编译期间，可将带有调试功能的 @AutoInit 注解替换掉。 以达到解耦，同步开发的目的。 @BindLife 注解 @BindLife 注解 顾名思义，是一个生命周期绑定注解，Example: 在AppWrapper中，我们定义的application如下。 1234567891011public class AppContext extends BaseApp &#123; @AutoInit(implClass = \"com.yixia.videoeditor.home.HomeApp\") @BindLife(isBefore = false) public IHomeApp mHomeApp; public void onCreate() &#123; super.onCreate(); &#125;&#125; 在Bridge中定义的IHomeApp如下。 123public interface IHomeApp &#123; void onCreate(IBaseAppContext app);&#125; 具体的实现类在 Home Module中。 12345678public class HomeApp implements IHomeApp &#123; public static final String TAG = \"HomeApp\"; @Override public void onCreate(IBaseAppContext app) &#123; //onCreateHome home &#125;&#125; 经过我们编译期注解处理之后，AppContext 变成了如下 1234567891011public class AppContext extends BaseApp &#123; @AutoInit(implClass = \"com.yixia.videoeditor.home.HomeApp\") @BindLife(isBefore = false) public IHomeApp mHomeApp = new com.yixia.videoeditor.home.HomeApp(); public void onCreate() &#123; super.onCreate(); mHomeApp.onCreate(this); &#125;&#125; BindLife注解会将同名,同参数（第一个参数为this）的方法绑定。","categories":[{"name":"android","slug":"android","permalink":"https://zyw.io/categories/android/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"https://zyw.io/tags/AOP/"},{"name":"组件化","slug":"组件化","permalink":"https://zyw.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"tramsform","slug":"tramsform","permalink":"https://zyw.io/tags/tramsform/"}]}]}